# Microarchitecture Specification

## 1. Introduction

This document describes the microarchitecture of a custom RISC-V processor.  
Its purpose is to record design intent at a level above the RTL, providing a reference for control signals, CSR definitions, pipeline organization, and major architectural blocks.  

This specification is intended to:  
- Capture high-level design goals and decisions.  
- Provide a consistent framework for development and debugging.  
- Serve as a point of reference for future extensions to the design.  

Details of specific modules, control signals, and CSR mappings are covered in later sections and supporting documents.

## 2. Supported ISA Features

### Currently Supported Features
The processor currently implements the RV32I base integer instruction set.  
This includes arithmetic, logical, branch, and memory operations, as well as load and store instructions. 

### Near-Term Planned Features
Features targeted for the next stage of development include:  
- Control and status registers (CSRs) and their associated instructions.  
- Basic performance counters (e.g., cycle and instruction retired counters).  
- The RV32M extension for hardware multiplication and division.  

### Tentative Longer-Term Planned Features
Future features that are under consideration, but not part of the immediate roadmap, include:  
- Exception and interrupt handling, including machine-mode CSRs.  
- More advanced performance monitoring.  
- Support for additional extensions or custom instructions.  
- Enhancements to enable benchmarking and accelerator integration.

For more information on the exact instructions supported and planned, please see [`supported_instructions.md`](supported_instructions.md).

## 3. Pipeline Organization

### Currently Implemented
The processor implements a five-stage, in-order pipeline:
1. **Instruction Fetch (IF)** – Retrieves instructions through the instruction cache, integrates branch prediction, and selects the next PC.  
2. **Instruction Decode (ID)** – Decodes instruction fields, generates control signals, and reads register operands.  
3. **Execute (EX)** – Performs ALU operations, branch evaluation, and address calculation.  
4. **Memory Access (MEM)** – Handles load and store instructions.  
5. **Writeback (WB)** – Commits results to the register file.  

Pipeline control includes:
- Hazard detection and resolution with forwarding support.  
- Pipeline stalls and flushes for load-use and control hazards.  
- A two-level branch prediction scheme with local predictors, a global predictor, and a branch target buffer (BTB).  
- Integrated instruction cache for improved fetch performance.  

### Near-Term Planned Enhancements
- Addition of a data cache to complement the instruction cache.  
- Expansion of performance monitoring, including CSR-based counters.  

### Longer-Term Planned Enhancements
- Multi-level cache hierarchy and unified memory integration.  
- Exception and interrupt handling, with pipeline flush and recovery support.  
- Exploration of deeper pipelines or superscalar execution.  

## 4. Major Components

The processor consists of the following major architectural blocks:

- **Datapath** – Implements the flow of instructions and data through the pipeline, including the register file, ALU, and pipeline registers.  
- **Control Unit** – Generates instruction-level control signals based on opcode and funct fields.  
- **Hazard Unit** – Detects and resolves pipeline hazards through stalls, forwarding, and flushes.  
- **Branch Processing Unit** – Provides a two-level branch prediction scheme with local and global predictors, supported by a branch target buffer (BTB).  
- **Instruction Cache** – Supplies instructions to the fetch stage.  
- **Data Cache (planned)** – Will provide cached data access in the memory stage.  
- **CSR File (planned)** – Will hold control and status registers, including performance counters and possibly machine state registers.  

Each component is documented in greater detail in its corresponding block-level document.

## 5. Control Signal Summary

Control signals coordinate the flow of data and the operation of modules throughout the pipeline.  
They are primarily generated by the Control Unit, Hazard Unit, and Branch Processing Unit, and are consumed by the datapath, caches, and other execution stages.  

A full dictionary of control signals is maintained in [`control_signals.xlsx`](spreadsheets/control_signals.xlsx).  
This spreadsheet records each signal’s source, destination, width, and purpose.  

At a high level:  
- The **Control Unit** generates signals that direct ALU operations, register file access, memory operations, etc.  
- The **Hazard Unit** injects stalls, flushes, and forwarding controls to preserve correctness under data and control hazards.  
- The **Branch Processing Unit** supplies prediction outcomes and target addresses to guide instruction fetch.  
- The **Cache controllers** assert ready/valid signals to manage access to memory.  

This section provides only a conceptual overview, the detailed specification of each signal can be found in the linked spreadsheet.

## 6. Control and Status Registers (CSRs)

Control and status registers (CSRs) provide access to processor state and performance counters.  
They are not currently implemented in this design, but support for CSRs and their associated instructions is planned as part of the next development stage.  

The CSR specification will be maintained in [`csr_spec.xlsx`](spreadsheets/csr_spec.xlsx).  
This spreadsheet will define:  
- CSR addresses and names.  
- Access permissions (read-only, write-only, or read/write).  
- Reset values.

Planned initial CSRs include:  
- **mcycle** – Cycle counter.  
- **minstret** – Retired instruction counter.  

This section serves as a placeholder until CSR functionality is integrated into the processor.

## 7. Memory System

### Currently Implemented
- **Instruction Cache** – A parameterizable instruction cache supplies instructions to the fetch stage.  

### Near-Term Planned Enhancements
- **Data Cache** – A first-level data cache will be added to support efficient load and store operations in the memory stage.  
- **Unified memory interface** – Integration of instruction and data caches with a shared interface to the next memory level.  

### Longer-Term Planned Enhancements
- **Multi-level caching** – Exploration of an L2 cache or unified cache hierarchy.  
- **External memory integration** – Connection to off-chip memory (e.g., DDR3) through a memory controller.  
- **Memory-mapped I/O** – Support for external peripherals and system-level features.  


## 8. Branch Prediction

### Currently Implemented
The processor uses a two-level branch prediction scheme to reduce control hazard penalties.  
This includes:  
- **Local predictors** that track the behavior of individual branches.  
- A **global predictor** that incorporates global branch history.  
- A **branch target buffer (BTB)** that caches predicted target addresses associated with branch instructions.  

This scheme enables the fetch stage to speculatively select the next program counter (PC), minimizing stalls from branch instructions.

### Future Possibilities
Branch prediction is considered stable in the current design.  
The approach may be revisited in the future if further development calls for alternative or more advanced prediction strategies.

## 9. Verification Strategy

Verification is used to establish correctness, measure performance, and guide ongoing development.  
The current strategy combines directed tests, benchmarks, and monitoring.  

### Currently Implemented
- **Unit-level testbenches** for core modules such as the ALU, register file, caches, and branch predictor.  
- **Directed assembly tests** for basic instruction functionality and corner cases.  
- **Regression testing infrastructure** to automate and repeat test runs. This will continually be improved.
- **Cycle and instruction counters** to track pipeline activity and performance.  
- **Basic benchmarks** (e.g., Dhrystone) to validate end-to-end functionality.  

### Near-Term Planned Enhancements
- **Expanded benchmarking**, including CoreMark and additional synthetic workloads.  
- **Integration of CSR-based performance counters** for monitoring cycles, retired instructions, and cache activity.  

### Longer-Term Planned Enhancements
- **RISC-V compliance testing** using standardized test suites.  
- **Benchmarking with larger programs** to better evaluate cache and branch prediction behavior.  


## 10. Related Infrastructure

Several supporting components exist alongside the processor to enable testing, benchmarking, and system integration.  
These are not part of the core microarchitecture but are essential for development and evaluation.  

### Currently Implemented
- **Assembly test programs** – Small, directed tests used to validate instruction functionality.  
- **C toolchain support** – Compilation and linking flow for running higher-level programs.  
- **Linker scripts and startup code** – Provide memory layout and initialization for programs.  
- **Regression testing framework** – Automates repeated runs of assembly tests and benchmarks.  

### Near-Term Planned Enhancements
- **Expanded benchmark infrastructure**, including scripts and harnesses for CoreMark and other workloads.  
- **Improved program I/O support**, such as stubs for common C library calls.  

### Longer-Term Planned Enhancements
- **Integration with external memory controllers and peripherals** via memory-mapped I/O.  
- **Support for larger software workloads**, possibly operating system kernels or advanced benchmarks.  

## 11. Appendices

The appendices provide reference material and supporting details that complement the main specification.  
They are not required to understand the processor at a high level but are useful for deeper technical work.  

### Glossary

#### General Architecture
**RISC-V (Reduced Instruction Set Computer – V)** – An open standard instruction set architecture (ISA) based on RISC principles.  
**RV32I** – The 32-bit base integer instruction set of RISC-V.  
**Register File** – The collection of architectural registers used for operand reads and result writes.  

#### Pipeline Concepts
**Pipeline Stall** – A one-cycle delay introduced into the pipeline to resolve a hazard or wait for resources.  
**Pipeline Flush** – The invalidation of in-flight instructions, typically due to a mispredicted branch or an exception.  
**Forwarding** – A hazard resolution technique that routes results from later pipeline stages back into earlier ones to avoid stalls.  
**Hazard** – A situation where the normal flow of instructions in the pipeline must be altered to maintain correctness.  
- **Data Hazard** – Dependency on the result of an earlier instruction.  
- **Control Hazard** – Arises from branch instructions and changes in program flow.  
- **Structural Hazard** – When hardware resources are over-subscribed.  
**WB (Writeback)** – The final pipeline stage where results are committed to the register file.  

#### Functional Units & Structures
**ALU (Arithmetic Logic Unit)** – Executes arithmetic and logical operations in the EX stage.  
**CSR (Control and Status Register)** – Special-purpose registers that provide access to machine state, performance counters, and system control.  
**I-Cache (Instruction Cache)** – A cache that stores recently accessed instructions for the IF stage.  
**D-Cache (Data Cache)** – A cache that stores recently accessed data for the MEM stage.  
**LRU (Least Recently Used)** – A cache replacement policy that evicts the block that has not been used for the longest time.  

#### Branch Prediction
**BTB (Branch Target Buffer)** – A small memory structure that caches predicted target addresses for branch instructions, used by the branch predictor.  

#### Performance Metrics
**IPC (Instructions Per Cycle)** – A performance metric measuring the average number of instructions retired per cycle.  

### Instruction Decode Table
See [`instr_decode_table.xlsx`](spreadsheets/instr_decode_table.xlsx) for the full instruction decode mapping.

### Control Signal Dictionary
See [`control_signals.xlsx`](spreadsheets/control_signals.xlsx) for a complete specification of all control signals.  

### CSR Map
See [`csr_spec.xlsx`](spreadsheets/csr_spec.xlsx) for the full control and status register definition.  

### Diagrams
Block diagrams, pipeline diagrams, cache organization, and timing diagrams that illustrate the microarchitecture.  