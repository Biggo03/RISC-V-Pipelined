# October

## October. 4th

### Notes:
Today was primarily focused on establishing comprehensive project documentation.  
I created a structured set of documents under the `docs/` directory covering all high-level topics related to the processor’s design and supporting infrastructure. This includes a central `README` outlining the purpose of each document and subdirectory, as well as a new `roadmap.md` file defining near- and long-term development priorities. The roadmap is intended to formalize my direction for the project and reduce sprawl, which became an issue over the past month.

The focus was on defining high-level documents that describe major design areas, along with spreadsheet files for organizing key control signal and instruction information. These will be crucial for maintaining consistency and supporting future expansion. The block-level documents remain as placeholders for now and will be populated as the design matures.  
The overall goal for the documentation structure is to balance stability and extensibility — central documents should only require occasional updates, while detailed leaf documents can evolve alongside the hardware.

### Summary:
- Created a complete set of high-level project documents.  
- Added a roadmap to define project direction and prevent sprawl.  
- Introduced spreadsheets for control signal and instruction organization.  
- Added skeletons for block-level documentation to be filled progressively.

## October. 6th

### Notes:
Today I began looking at what would be needed to implement the CSR instructions I have planned to add. Of course there's the design of the CSR register, but I also need to determine how it will interact with the rest of the design. Ideally, I want to add the least amount of signals and hardware possible.

I will go over the functionality required for each planned instruction, and my initial plan in implementing said functionality:
    - csrrw: atomic read/write CSR
        - This instruction reads the value of the CSR, and writes that value to **rd**. The source registers value (**rs1**) is then written to the CSR register. This will require:
            - Reading from the CSR reg file (don't need to worry about sign extnesion for now, all registers are XLEN bits (32-bits)
            - Writing the read value from the CSR to the destination register
            - Writing the read value from the standard reg value to the CSR register
    - csrrs: atomic read and set bits in CSR:
        - This instruction reads the value of a CSR, and writes it to **rd**. The value of **rs1** is treated as a bit mask for setting bits in the CSR. This will additionally require:
            - Effectively ORing the CSR reg value, and the value read from **rs1**. This is because this instruction specifies that unmasked bits (bits set to 0 in **rs1**) are to be unaffected, and all other bits are to be set.
            - No additonal functionality in addition to the previous instruction is needed.
    - csrrc: atomic read and clear bits in CSR
        - Reads the value of a CSR and writes it to **rd**. The value of **rs1** os treated as a bit mask for clearing bits in the CSR.
        - This should not require any additional functionality that the previous instructions don't also require
    - csrrwi, csrrsi, csrrci:
        - Same as their non-i counterparts, but done with an immediate encoded in the rs1 field, rather than the register value stored in rs1.
        - The value in the CSR register is still written to the destination registr (**rd**)
    


To summarize, the additions needed to support these new instructions are as follows:
    - Be able to read from and write to both **rs1** and the **CSR** in the same cycle
    - Perform ALU operation on the data read from the **CSR**, and the data read from **rs1**
    - Perform ALU operations on the data read from the **CSR**, and an immediate
    - Extend immediates encoded in the rs1 field
    - Route the values read from the **CSR** and **rs1** back to the standard register file, and the CSR

I believe to implement these features, the main architectural changes are:
    - Routing values read from the **CSR** and **rs1** to the writeback stage
    - An additional multiplexer in the writeback stage to determine what value is to be written to the CSR
    - Multiplexers within the decode stage to determine what values are sent to the execution stage
    - A CSR register file
    - Control signal to accomodate new multiplexers, new multiplexer inputs, and to control the CSR reg file behaviour
        - Includes neccesary changes to main decoder
    - Additional option within extension unit to handle extending immediates encoded in the rs1 field appropriately.

I believe these architectural changes should allow for execution of these instructions. The first step in developing this will be creation of the CSR register file

In addition to this, I also changed the name of the rd1 and rd2 signals to reg_data_1 and reg_data_2. This is becuase rd also stands for the destination register field, which reduced clarity.

### Summary:
- Scoped out changes needed for implementation of CSR's
- Changed signal name

## October. 7th

### Notes:
I began looking into how I wanted to implement the CSR register file in more depth. At this point, I already have a bare bones implementation that I created a week or two ago when I first looked into adding CSR's, so I used this as a starting point. 

The first thing I did was update it to allow for a unique read and write address, and then I allowed for forwarding data, which is essentially just passing the wdata signal to the read output when the read and write addresses match. With that implemented, the file now has macros for each implemented CSR, and should have the basic functionality (although untested).

That said, after looking at this, I thought it may be a good idea to use a script to maintain this file. I'm already planning on using an excel sheet to organize everything related to my CSR registers, so parsing that using a script to generate an otherwise extermely long and repetitive module seems like a good way to go to ensure that the module remains extensible.

I haven't begun work on this script, this was just something I thought of while looking over my old module. With the amount of CSR's I currently have implemented, it definitely isn't neccesary, but it is something I'm interested in doing, and it will absolutely future proof the module, so I think it's worth getting into.

This script would need a template file, or some other way to handle the functionality that's required, and it would also need a way to deal with registers that are updated on a per-cycle basis, like mcycle and minstret. My initial though is to have a module that deals with these functions seperately, and have the relevent values linked to the appropriate registers within the register itself.

All of this will be expanded upon further in the very near future.

While thinking about scripting, I thought it would be good to update my script directory strucure, so I did just that. While doing so, I saw that identical file lists were being made for each risc-v program being run when, so I updated run_regression.py (now test_driver.py) to only generate one file list for integration, or "system" level tests.

### Summary:
- Initial update to csr_regfile module
- Looked into script to maintain csr_regfile
- Updated script directory
- Updated run_regression.py (now test_driver.py) script
