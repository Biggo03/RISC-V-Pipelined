# August 2025

### Current state of the project
As of now, I'm getting back into this project after a couple months hiatus. In that time I've gained some experience in my ASIC design internship, and as such have a lot of ideas for restructuring the project to be more professional. In addition, I will now be working on a linux system, which will allow for more scripting automation, and command line tools, which will allow for advancement of the project.

That said, as I am just getting back into it, the first steps of this will be the setup of my new workspace, accounting for changes in the environment. After that I plan on refactoring almost every part of the project. This will include a directory organization refactor, RTL code refactor, testbench refactor, and documentation refactor. I feel this is necessary to move forward effectively, as it will allow for much easier maintenance, addition of features, and debugging, things that are essential as this project grows in scope.

### Goals for the month
I'm starting near the end of August, so the main goals for the month are to:
- setup my workspace (including some automation scripting)
- Transfer my RTL from Verilog to SystemVerilog
- Do a style refactor for my file names, and RTL code
- Confirming that the design still works as intended for most modules
  - Will include the design of a regression test script that runs a number of tests
- Possibly adding in some new organizational features into my RTL (things like macros)

## Aug. 24th

### Notes:
After doing some work in industry, I've found how useful macros can be in organizing a large design. As such, I thought it would be a great idea to start adding macros into my design. I started with the main decoder, changing opcodes, and control signals to macros. This was mostly just to try it out, and the structure may change in the future. 

I also decided that my repo really needed a refactor. Previously it was just based on Vivado's file structure, which does not have clear naming for my purposes. Additionally, because of how adding and creating files to a project works in Vivado, there were file duplicates, and long paths including directories with nothing, all of which is really bad for organization. Because of this, I decided to refactor it into a more organized structure detached from Vivado (although Vivado will still be used). As of now, the structure is:
Project top:
- rtl: RTL code
- tb: testbenches
- scripts: scripts
- constr: design constraint files
- docs: new documentation
- legacy_docs: old documentation
- test_inputs: files that are inputs to tb's

### Summary:
The following was achieved today:
- Addition of macros within the main_decoder module
- Directory structure refactor of the repo

## Aug. 26th

### Notes:
Began working on setting up my workspace for linux, using new tools, including icarus verilog, and GTKWave. I wanted to get everything setup so that I could run my testbenches and view my waveforms using these new tools. 

As such, I created a script for generating testbenches using icarus verilog. This script takes in the testbench, the simulation name, and the output directory for the waveform files. This was great, however because of my new tooling, I needed to include waveform dump commands within my testbenches in order to actually view the generated waveforms. Because of this limitation, and because I thought it could be useful in the future, I thought it would be good to create a file containing common tasks used in testbenches. So I created this file, and made a task that dumps waveforms to a location specified by a macro. This macro is defined in the script, allowing for user defined dumping locations.

### Summary:
- Setup workspace with new tools
- Created script for running testbenches
- Created file for common TB functions
- Created task for dumping waveforms

## Aug. 29th

### Notes:
Today I started refactoring my RTL, and file names. I decided I wanted a couple things to be consistent: file names, module/port declarations, module instantiations, signal declarations, file headers, and signal name. I got around to each of these except for signal names, as these will be a bit more of an undertaking considering their's so many across so many different modules and testbenches.

I started by transferring all of my RTL files from *.v to *.sv, which was done with a simple command. After this, I renamed all my design files (rtl, tb), as well as the module names within them to be in snake_case for consistancy. The decision for snake_case was relatively arbitrary, but I like it, and the main point is that everything is consistent.

Once that was done, I moved to module/port declarations. Previously, I had multiple ports instantiated in a given line, and for the most part, no descriptions or sections for ports in my module declarations. This makes it hard to maintain and update. As such I moved to a style in which one port is listed per line, and there are sections for each category of signal. Additionally, I changed all types for ports to be **logic**. From there, I changed the module instantiations to be similar to the port instantiations style, having one port per line, and sections for each category of signal. Additionally, the names of instantiated module was also changed to be standard. I additionally standardized how parameters were handled in the module declarations and instantiations.

All internal signals were also changed to the **logic** type, and their declarations were made more structured. All signals are defined directly after the module declaration, and have sections based on how they are used (much like the port sections).

I additionally made a **style_guide.md** file that goes over the specifics of this new style. For details on the style, please see this file.

### Summary
- Changed all RTL verilog files to be SystemVerilog
- Renamed RTL and TB files to be in snake_case
- Renamed modules to be in snake_case
- Renamed module instantiations to have standard format
- Updated module declaration style
- Updated signal declaration style
- Updated module instantiation style

## Aug. 30th

### Notes:
Today I worked on creating a regression test script, and refining my compilation/testing framework. This is all foundational work that needs to be done to allow for effecient development, which is why I chose this as my next step. The regression script is written in python, with tests stored in a YAML file. As far as python for the script, this ideally allows for relatively complex processing, while retaining readibility. In addition, python handles YAML files very well, and I'm also relatively comfortable with python already, all pluses. I chose YAML to store the tests, as it provides a human readable way to store test information, and makes adding or removing tests decoupled from the script.

The yaml file is currently called **regression_tests.yml**, and the python file is currently called **run_regression.py**. The script is currently very crude, and requires a lot of updates, but as of now it is able to run a set of tests provided by the yaml file. Future additions will include proper logging, dynamic file list generation, and possibly other features. I plan on implementing these ASAP, as again, this is fundamental to being able to develop the rest of the project effeciently.

Today I also made hierarchical file lists for each module. These will be depracted very soon, as the hierarchical nature means that the same modules are instantiated multiple times in higher level module file lists. These will be replaced by the dynamically generated file lists.

Additionally, I worked on gettin my testbenches to compile and run properly with the new setup. This required changing some things in the TB's style, and the data structures used, as well as updating some TB's to include the proper ports for certain modules. Additonally, I standardized the end of each TB, adding a "TEST PASSED" message and $finish at the end of each one, which was done to ensure they finish gracefully, and to allow for easy parsing to determine which tests passed. This made me realize how much the TB's need to be updated to ensure correctness, and proper style. I don't plan on doing a sweeping refactor on the TB's, but I do plan on making some updates to ensure they are stylistically consistant, and verify correctness for the intended modules correctly.

In the future, I plan to maintain the TB's more rigoursly to ensure that my regression tests always pass, and the style remains consistant.

### Summary:
- Initial regression script created
- Regression test YAML created
- File lists for each TB created
- Standardized TB ending
- Fixed some issues with TB's

## August. 31st
Today I mainly worked on my regression script. I added dynamic file list generation, utilizing the standardization of module instantiations names (u_<name>). This is far simpler, and more robust than my previous method of parsing file lists and manually creating file list hierarchies. In addition to this, I added some basic logging, which displays how many and which tests passed/failed.

While doing all this, I also made some small TB fixes that I found while running the regressions. I also found a real bug in my register file RTL. It was found that the write through feature of the register file didn't account for the 0 address. So if the write and read address was 0, and write data was 5, the output would be 5. This was an issue, because the 0 addressed register is intended to be hardcoded to the value of 0. So this needed to be changed to exclude the zero register from being written through.

### Summary:
- Regression script refinement
- Dynamic filelist generation
- Bug fixes