# September

## September 4th

### Notes:
Today I began refactoring the hazard unit testbench. This module is very important to the execution of the whole system, so it's very important that it is thoroughly verified, especially with the complications included through the addition of the instruction cache, and branch predictor. 

To start, I decided it would be best to make use of more tasks, one for each expected case I wanted to test. In this way I can make each case I want to test it's own block of code that can be updated as needed. This extra organization should make future changes much easier to verify. 

Each scenario will have a driver task, which will set **only** the related signals, and a checker task that will assert the expected results. The scenario drivers can be combined to test when multiple hazards may overlap (like a load stall, and cache miss at the same time), however these combined scenarios will require their own checker tasks to handle priority.

Today was a short day, so I essentially just made this decision, and layed out some of the tasks that need to be created within the hazard unit testbench. Note that this kind of refactor will not be done for most testbenches, however I feel it is worth it for this one, as the hazard signals are so important in how the processor functions.

### Summary
- Decided on testing method for hazard unit
- Layed out tasks to create
  
## September 6th

### Notes:
Today I implemented the changes to the hazard unit tb. This ended up being a pretty split development. I created some drive* tasks for simple situations, scenario* tasks for more complex situations, and then expect* tasks for both. Essentially, when a situation was multi-cycle, and dependant on a specfic scenario, it became a "scenario" task. When it was a simple combination input to output situation, it became a "drive" task. Ultimately, this ended up in the testbench being a bit messy, but it does confirm the functionality. I'm not trying to be incredibly rigorous with this testing, I just wanted it to be reliable. So I'm leaving it as is. I also didn't touch the forwarding checking, as that worked just fine, and had no changes made related to it.

I also created a macro that essentially acts as a function. It takes in a condition, a message, and 2 arguments. It asserts the condition, and if it fails it prints the message, including the 2 arguments in the string where applicable. This was added to the tb/common directory in a file called "tb_macros.sv", which from now on will contain tb related macros.

After the hazard TB was updated, I moved on to the other tests that were failing their tests. This mostly lead to testbenches being updated to reflect new expected behaviour. However, in one case there was an issue with the RTL. While debugging the branching buffer, it was found that the local predictors were behaving incorrectly. This was because of how the output was being assigned, how the newstate was being determined, and how the present state was being assigned. To say the least, it revealed a number of important issues in the RTL, which were then fixed.

I also updated some files to allow the regression parser to properly determine modules that contained parameters in their instantiation. The parser expects the module, as well as the instance name on the same line, however my current instantiation style for modules with parameters has the module name a couple of lines above the instance name. To solve this, I added a hack, where I duplicate the instance name on the same line as the module name, allowing the parser to find the module name. This isn't ideal, but it is an easy fix, and will work well enough.

In addition to this, restyled all the testbenches to match the same module and signal instantiation/definition style as my RTL. The TB's themselves were not changed. I also updated some signals that pass only specific parts of a signal between module boundries as a specific name. For example, funct7b5 which represents the 7th bit of funct7 was just changed to funct7, and the 5th bit was then indexed within the module. This cleans up module boundries quite a bit, and improves clarity, both of which will be things that will be valuable as development continues.

### Summary:
- Fixed and updated hazard unit TB
- Fixed and updated all other failing test TB's
- Fixed issues in the local predictor RTL
- Fixed issues related to module parsing for compilation
- Updated TB module and signal style
- Changed single bit signals to pass whole signal, and index within module

## September 7th

### Notes:
Today I focused on changing all of my signal names to match the snake_case style I'm going for, as well as include pipeline stage, and i/o information more cleary. The style I decided on was: **<signal_name>_<pipeline_stage>_<i/o>**. Here, the i/o suffix is dependant on the scope of each module. So if a signal is an input to a module, it will have the _i suffix, if it is an output it will have the _o suffix, and if it is an internal signal, it will have neither suffix. This should Ideally provide clarity when debugging, as it will be clear that a signal is either internal to the module, an input, or an output.

To do this I created a script. This script takes in a csv file in the format <old_signal_name>,<new_signal_name>. It does two passes of the input files, one to create a renaming map, and one to apply the changes, and either write to a new file, or overwrite the old one. The renaming map determines what old signals that need to be renamed exist in the module, and what their new name is to be, taking into account suffixes. Note that in my design, signals are already specifed by pipeline stage, ending with F for fetch stage, D for decode stage, etc. When I say that my script takes suffixes into account, I mean it will transfer this F into the properly stlyed _f, and additionally add _i or _o, if the signal is an input or output signal for a given module.

For example, say I want to do the rename (OldSignal,new_signal), and lets say this old signal is specified as being an F stage signal, and is an input for a given module. This means that the old signal is named OldSignalF. My script will find this signal, see it is an F stage signal, and an input, and therefore have it's new name mapped as **new_signal_f_i** for that specific module.

Once all signals are remapped, the second pass uses regex operations to search for the old signal names, and replace them with the new mapped name. 

Some extra complexity is added by module instantiations, as some modules may have different port names when compared to the instantiating module (internal signal for top, port for instantiated). To handle this, I made it so that the instantiated modules renaming map is used for the ports while it is being instantiated, while keeping the top modules renaming map used for the signals connected to the ports. This is agian done using regex operations.

Ultimately it ended up working quite well, and changing all the signals accordingly. It can also act as a style enforcer for the _i and _o suffixes. If the new_signal_name and old_signal_name are the same, it will just update the signals to match the _i and _o style guideline, which is nice to have!

### Summary:
- Created script to update all signal names in project
- Used script to update all signal names in project

## September 8th

### Notes:
Today I looked at adding enum types and macros into my design to improve readibility. I started with deciding what I wanted to be an enum, and what I wanted to be a macro. This is what I've decided on as of now:
Enum:
  - funct3 -> individual enum type for each type of instruction for clarity
  - Control signals
Macros:
  - Opcodes
  - funct7 -> only have two valid values for implemented instruction

I feel that this will provide plenty of clarity in the code itself, and having control signals and funct3 show up with descriptive names in the wave viewer will be game changer. The opcodes aren't used in many locations, but it will be good for them to have descriptive names where they do appear, I just thought the overhead of an enum type for the opcodes wasn't worth it.

Aside from deciding the general direction for implementing these features into the design, I also created the package for funct3 as a start. It hasn't been implemented or tested, as today was a short session.

### Summary:
- Determined plan for macros and enum type implementation
- Created funct3 package